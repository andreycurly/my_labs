= Процесс компиляции в IAR Workbench for ARM

Процесс преобразования кода на языке программирования *C++* в исполняемый файл для микроконтроллера состоит из двух основных этапов.

== 1. Трансляция кода в объектный файл

Этот этап выполняет *компилятор*. Он берет ваш исходный код и превращает его в *объектный файл*.

После трансляции можно получить два типа файлов:
- *Объектные файлы*, содержащие машинный код;
- *Файлы библиотеки*, которые можно использовать в других проектах.

== 2. Компоновка кода в исполняемый файл

На этом этапе *линковщик* объединяет все необходимые файлы и формирует *исполнимый образ* программы.

На входе линковщика могут быть:
- *Внешние библиотеки*, добавляемые в проект;
- *Объектные файлы*, полученные на этапе трансляции;
- *Стандартные библиотеки C++*;
- *Конфигурационный файл*, который определяет размещение кода и данных в памяти микроконтроллера.

После завершения работы линковщика создаётся *исполняемый файл*, готовый к записи в микроконтроллер.

== 3. Запуск и отладка

После компоновки IAR создает *файл в формате ELF*, который можно использовать для:
- *Загрузки в систему отладки* (например, IAR-CSPY или GDB);
- *Записи в ПЗУ микроконтроллера* с помощью программатора.

== Заключение

Процесс компиляции в *IAR Workbench for ARM* включает два ключевых этапа:
1. *Трансляция кода* — преобразование исходного кода в объектные файлы;
2. *Компоновка* — создание исполняемого файла из объектных файлов, библиотек и конфигурационных данных.

После этого файл можно загрузить в микроконтроллер и запустить программу.

== Запуск функции main() в микроконтроллере

После загрузки исполняемого файла в память микроконтроллера выполняются подготовительные действия, необходимые до вызова функции main().

=== 1. Инициализация стека и переменных

Первым шагом является инициализация *стека* и *глобальных переменных*. Стек — это область памяти для хранения локальных переменных и данных вызовов функций. Также инициализируются статические переменные.

=== 2. Копирование данных из ПЗУ в ОЗУ

Данные из постоянной памяти (*ПЗУ*), сохранённые при компиляции, копируются в *ОЗУ* для более быстрого доступа при выполнении программы.

=== 3. Инициализация периферийных устройств

Происходит настройка периферийных устройств (таймеры, GPIO, интерфейсы и т.д.), как правило, с помощью стандартных библиотек и драйверов.

=== 4. Передача управления в функцию main()

После всех подготовительных этапов управление передаётся в функцию main(), и начинается основное выполнение программы.

====
До запуска main() выполняются:
1. Инициализация стека и глобальных переменных;
2. Копирование данных из ПЗУ в ОЗУ;
3. Инициализация периферии;
4. Передача управления в main().
====

== Объяснение работы статической переменной в функции

Пример кода:

[source,cpp]
----
#include <iostream>

int Increment(int value)
{
    static int result = value;
    result++;
    return result;
}

int main()
{
    auto result = Increment(10);
    std::cout << "result == " << result << std::endl; // 11

    result = Increment(12);
    std::cout << "result == " << result << std::endl; // 12
}
----

=== Что такое статическая переменная?

static переменная в функции сохраняет своё значение между вызовами. Она инициализируется один раз — при первом вызове — и сохраняет состояние, даже после выхода из функции.

=== Пояснение к примеру

- При первом вызове Increment(10) переменная result инициализируется значением 10, затем увеличивается до 11.
- При втором вызове Increment(12) переменная result сохраняет своё значение 11, и увеличивается до 12. Значение параметра value уже не влияет на инициализацию.

=== Итог

Результат работы программы:
- Первый вывод: result == 11
- Второй вывод: result == 12