= Процесс компиляции в IAR Workbench for ARM

Процесс преобразования кода на языке программирования *C++* в исполняемый файл для микроконтроллера состоит из двух основных этапов.

== 1. Трансляция кода в объектный файл

Этот этап выполняет *компилятор*. Он берет ваш исходный код и превращает его в *объектный файл*.

После трансляции можно получить два типа файлов:
- *Объектные файлы*, содержащие машинный код;
- *Файлы библиотеки*, которые можно использовать в других проектах.

== 2. Компоновка кода в исполняемый файл

На этом этапе *линковщик* объединяет все необходимые файлы и формирует *исполнимый образ* программы.

На входе линковщика могут быть:
- *Внешние библиотеки*, добавляемые в проект;
- *Объектные файлы*, полученные на этапе трансляции;
- *Стандартные библиотеки C++*;
- *Конфигурационный файл*, который определяет размещение кода и данных в памяти микроконтроллера.

После завершения работы линковщика создаётся *исполняемый файл*, готовый к записи в микроконтроллер.

== 3. Запуск и отладка

После компоновки IAR создает *файл в формате ELF*, который можно использовать для:
- *Загрузки в систему отладки* (например, IAR-CSPY или GDB);
- *Записи в ПЗУ микроконтроллера* с помощью программатора.

== Заключение

Процесс компиляции в *IAR Workbench for ARM* включает два ключевых этапа:
1. *Трансляция кода* — преобразование исходного кода в объектные файлы;
2. *Компоновка* — создание исполняемого файла из объектных файлов, библиотек и конфигурационных данных.

После этого файл можно загрузить в микроконтроллер и запустить программу.

== Запуск функции main() в микроконтроллере

После загрузки исполняемого файла в память микроконтроллера выполняются подготовительные действия, необходимые до вызова функции main().

=== 1. Инициализация стека и переменных

Первым шагом является инициализация *стека* и *глобальных переменных*. Стек — это область памяти для хранения локальных переменных и данных вызовов функций. Также инициализируются статические переменные.

=== 2. Копирование данных из ПЗУ в ОЗУ

Данные из постоянной памяти (*ПЗУ*), сохранённые при компиляции, копируются в *ОЗУ* для более быстрого доступа при выполнении программы.

=== 3. Инициализация периферийных устройств

Происходит настройка периферийных устройств (таймеры, GPIO, интерфейсы и т.д.), как правило, с помощью стандартных библиотек и драйверов.

=== 4. Передача управления в функцию main()

После всех подготовительных этапов управление передаётся в функцию main(), и начинается основное выполнение программы.

====
До запуска main() выполняются:
1. Инициализация стека и глобальных переменных;
2. Копирование данных из ПЗУ в ОЗУ;
3. Инициализация периферии;
4. Передача управления в main().
====

== Объяснение работы статической переменной в функции

Пример кода:

[source,cpp]
----
#include <iostream>

int Increment(int value)
{
    static int result = value;
    result++;
    return result;
}

int main()
{
    auto result = Increment(10);
    std::cout << "result == " << result << std::endl; // 11

    result = Increment(12);
    std::cout << "result == " << result << std::endl; // 12
}
----

=== Что такое статическая переменная?

static переменная в функции сохраняет своё значение между вызовами. Она инициализируется один раз — при первом вызове — и сохраняет состояние, даже после выхода из функции.

=== Пояснение к примеру

- При первом вызове Increment(10) переменная result инициализируется значением 10, затем увеличивается до 11.
- При втором вызове Increment(12) переменная result сохраняет своё значение 11, и увеличивается до 12. Значение параметра value уже не влияет на инициализацию.

=== Итог

Результат работы программы:
- Первый вывод: result == 11
- Второй вывод: result == 12

== Почему код пишут самые низкоквалифицированные инженеры?

Забыл написать. *Я считаю*, что код пишут самые низкоквалифицированные инженеры, потому что в наше время есть большое количество нейросетей, которые неплохо умеют это делать. Если правильно поставить задачу нейронке (написать хороший промпт), тогда она выдаст неплохой ответ, который по ходу диалога можно довести до ума. Задача разработчика - понять цель, которая перед ним лежит и правильно анализировать ответы нейронки (логичный ли получился код или что-то стоит переделать/доделать?).

== Что я узнал за эту неделю, и что сделал

На самом деле, я поздно приступил к выполнению задач (скачиванию IAR Embedded Workbench, что, где, как тыкать в GitHub), потому что ленился и не только. Сейчас я +- разобрался, но сильно не углублялся в работу самого микроконтроллера (то, как у него там все устроено). По большей части я посидел в GitHub, потыкал там все и, надеюсь, понял, как создавать репозиторий и прикреплять там лабораторные :).

== 1. Какие типы данных бывают? (Для нашего микроконтроллера)

- *Встроенные типы*
- *bool* — 1 байт — Представляет значения true или false.
- *char* — 1 байт — Символ ASCII, используется в C-строках или std::string без преобразования в Юникод.
- *unsigned char* — 1 байт — Аналог байта, с C++17 есть std::byte.
- *int* — 4 байта — Целочисленное значение, выбор по умолчанию для целых чисел.
- *unsigned int* — 4 байта — Беззнаковое целое число.
- *float* — 4 байта — Число с плавающей точкой, аппаратно поддерживается некоторыми микроконтроллерами.
- *double* — 8 байт — Число с плавающей запятой двойной точности, выбор по умолчанию для значений с плавающей точкой.

- *Модификаторы типов данных*
- *short int* — 2 байта — Целочисленное знаковое значение укороченной длины.
- *unsigned short int* — 2 байта — Целочисленное беззнаковое значение укороченной длины.
- *long int* — 8 байт — Выбор по умолчанию для целочисленных значений, может быть длиннее int на некоторых платформах.
- *unsigned long int* — 8 байт — Беззнаковое целое число, может быть длиннее int на некоторых платформах.
- *long double* — 8 байт — Число с плавающей запятой двойной точности с увеличенной точностью.

== 2. Как вычисляется их размер?

Размер типа данных зависит от архитектуры процессора и компилятора. Из лекции: 

Для размеров типов существует правило:

1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)

== 3. Что такое неявное преобразование типа?

Неявное преобразование происходит автоматически, когда значение одного типа присваивается переменной другого типа. Например, если int преобразуется в float без явного указания программиста.

== 4. Что такое явное преобразование типа?

Явное преобразование требует, чтобы программист сам указал, в какой тип преобразовать значение. Для этого используются операторы преобразования, такие как static_cast, reinterpret_cast, dynamic_cast, const_cast.

== 5. Когда используется static_cast?

Этот оператор используется для безопасного преобразования между совместимыми типами, например, из int в double.

== 6. Когда используется reinterpret_cast?

Этот оператор позволяет интерпретировать один тип как другой, даже если они несовместимы. Например, можно преобразовать int* в char*. Однако такое преобразование может привести к ошибкам, если программист неправильно интерпретирует данные.

== 7. Почему преобразование одного типа в другой может быть проблемой?

Преобразование типов может привести к потере данных (например, при преобразовании double в int дробная часть теряется) и неопределенному поведению программы (особенно при использовании reinterpret_cast). 

== 8. Что такое указатель?

Указатель — это переменная, содержащая адрес другой переменной.

== 9. Почему нельзя вычитать один указатель из другого, если они указывают на разные объекты?

Разность указателей имеет смысл только в пределах одного массива или объекта. Если вычесть указатели, принадлежащие разным объектам, результат будет неопределенным, так как они могут находиться в совершенно разных частях памяти.

== 10. Как установить бит?

Можно использовать *побитовое ИЛИ*:
x = x | (1 << n);
(устанавливает n-й бит в 1)

== 11. Как сбросить бит?

Используется *побитовое И с отрицанием*:
x = x & ~(1 << n);
(устанавливает n-й бит в 0)

== 12. Как переключить бит?

Применяется *побитовое XOR*:
x = x ^ (1 << n);
(меняет n-й бит с 0 на 1 или наоборот)

== Операция унарного + и -

В C++:
Унарный + ничего не меняет (+x то же самое, что x).
Унарный - меняет знак числа (-x).

== Почему 17000000 + 1 == 17000000 для float?

Число 17000000 (1.7e7) в float представляется с точностью около 7-8 значащих цифр. Когда к нему прибавляют 1, разница слишком мала по сравнению с величиной числа, и значение не меняется из-за ограниченной точности представления float.